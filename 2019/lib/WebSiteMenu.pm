package WebSiteMenu;

require Exporter;
our @ISA = qw(Exporter);
our @EXPORT
  = (
     'gen_yui_main_menu',
    );

# used to generate menus for https://usafa-1965.org
use strict;
use warnings;
use Readonly;
use Data::Dumper;
$Data::Dumper::Sortkeys = 1;
use Geography::States;

use CLASSMATES_FUNCS qw(%countries);
use CL;

my $debug  = 0;
my $cfil   = 0;
my $mfil   = 0;

# defaults
my $iprog  = 'manage-web-site.pl';

# menus are in levels top to bottom
my %menu; # defined in BEGIN block at the end of the file
# menu left padding (used in get_spaces)
Readonly my $PAD => 4;
# need a unique index for submenus
my $menuidx = 1; # starting number
Readonly my $ofil => 'index.html.menu'; # for production

#### subroutines ####
sub gen_yui_main_menu {
  my $debug = shift @_;
  $debug = 0 if !defined $debug;

  # add an extra menu item for debugging maps
  if (0 && $debug) {
    die "UNEXPECTED!  Menu '3' NOT 'Class Maps'"
      if ($menu{3}{title} ne 'Class Maps');

    $menu{3}{submenu}{99}{title} = 'Debug Map';
    $menu{3}{submenu}{99}{href}  = './maps/classmates-map-debug.html';
    $menu{3}{submenu}{99}{class} = 'menu-temp';
  }

  open my $fp, '>', $ofil
    or die "$ofil: $!";

  # print headers
  {
    # this is MENU MARKUP
    print $fp <<"HERE";
<!-- THIS FILE IS AUTO-GENERATED BY 'WebSiteMenu.pm': ALL EDITS WILL BE LOST!! -->
<!-- **** YUI Menu Plug-in BAR -->
<div class='yui3-skin-sam'>
<!-- note: only 'menu-label' gets <em></em> pair if used -->
<div id='menu-1' class='yui3-menu yui3-menu-horizontal'><!-- Root Menu Bounding box -->
  <div class='yui3-menu-content'>  <!-- Root Menu Content box -->
    <!-- Main Menu items -->
    <ul>
HERE
  }

  # a one-shot, recursive function to handle all menu details
  my $toplevel = 0;
  handle_submenu_hash($fp, $toplevel, \%menu);

  # enders
  {
    print $fp <<"HERE";
    </ul>
    <!-- end of main menu list -->
  </div>
</div>
<div class='sep'></div>
</div><!-- class='yui3-skin-sam' -->
<!-- **** END YUI Menu Plug-in BAR **** -->
HERE
  }

} # gen_yui_main_menu

sub remove_states {
  my $sref = shift @_;

  my %used = ();
  foreach my $k (keys %CL::mates) {
    next if $CL::mates{$k}{deceased};
    next if !$CL::mates{$k}{state};
    $used{$CL::mates{$k}{state}} = 1;
  }

  #print Dumper(\%used); die "debug exit";

  foreach my $s (keys %{$sref}) {
    #print "debug: state '$s'\n";
    #print "debug: deleting state '$s'\n" if !exists $used{$s};
    delete $sref->{$s} if !exists $used{$s};
  }

} # remove_states

sub get_spaces {
  # should be in a module--but  maybe not
  my $level = shift @_;
  my $pad   = shift @_;

  $pad = 0 if !defined $pad;

  my $len = $PAD + ($level * $PAD) + $pad;

  my $s = '';
  for (my $i = 0; $i < $len; ++$i) {
    $s .= '  '; # two spaces per level
  }
  return $s;
} # get_spaces

sub handle_submenu_hash {
  my $fp        = shift @_;
  my $thislevel = shift @_;
  my $href      = shift @_;

  my $spaces = get_spaces($thislevel);

  my %h = %{$href};
  foreach my $k (sort { $a <=> $b } keys %h) {
    # a menu with a submenu (may be autogenerated
    my $title = $h{$k}{title};
    print "${spaces}Level $thislevel menu $k: '$title'\n"
      if $debug;

    my $sub  = exists $h{$k}{submenu} ? 1 : 0;
    my $auto = exists $h{$k}{href} && $h{$k}{href} eq 'auto' ? 1 : 0;
    die "Impossible: \$sub AND \$auto" if ($sub && $auto);
    my (%h1);
    %h1 = %{$h{$k}{submenu}} if $sub;
    my $typ = exists $h{$k}{type} ? $h{$k}{type} : '';
    %h1 = get_auto_menu($title, $typ) if $auto;

    if ($sub || $auto) {
      # need to write the submenu beginning part
      write_yui_submenu_item_begin($fp, $thislevel, $title);

      # write the child menus
      my $level = $thislevel + 1;
      handle_submenu_hash($fp, $level, \%h1);

      # need to write the submenu ending part
      write_yui_submenu_item_end($fp, $thislevel);

      next;
    }

    # handle a menuitem
    print "${spaces}  (no submenu)...\n"
      if $debug;
    write_yui_menu_item($fp, $thislevel, \%{$h{$k}});
  }

} # handle_submenu_hash

sub write_yui_menu_item {
  my $fp      = shift @_;
  my $level   = shift @_;
  my $hashref = shift @_;

  my $sp = get_spaces($level);

  my $title = $hashref->{title};
  my $href  = $hashref->{href};
  my $class = $hashref->{class};
  $class = '' if !defined $class;

  my $fontclass = 'yui3-cssfonts';

  print $fp <<"HERE";
$sp<!-- a menu item -->
$sp<li class='yui3-menuitem $class $fontclass'><!-- Bounding box -->
$sp  <a class='yui3-menuitem-content'
$sp     href=\"$href\"><!-- Content box -->
$sp     $title
$sp  </a>
$sp</li>
$sp<!-- end menu item -->
HERE

} # write_yui_menu_item

sub write_yui_submenu_item_begin {
  my $fp    = shift @_;
  my $level = shift @_;
  my $title = shift @_;

  my $sp = get_spaces($level);

  print $fp <<"HERE";
$sp<!-- a submenu parent ========== -->
$sp<li>
$sp  <a class='yui3-menu-label'
$sp     href=\"#submenu-$menuidx\"
$sp  >$title</a><!-- Submenu Label -->
$sp  <div id='submenu-$menuidx' class='yui3-menu'><!-- Submenu Bounding box -->
$sp    <div class='yui3-menu-content'>            <!-- Submenu Content box -->
$sp      <ul>
$sp        <!-- Menu items -->
HERE

  # don't forget to increment the menu index
  ++$menuidx;

} # write_yui_submenu_item_begin

sub write_yui_submenu_item_end {
  my $fp    = shift @_;
  my $level = shift @_;

  my $sp = get_spaces($level);

  print $fp <<"HERE";
$sp      </ul>
$sp    </div>
$sp  </div>
$sp</li>
$sp<!-- end submenu parent ========== -->
HERE
} # write_yui_submenu_item_end

sub get_auto_menu {
  my $mtitle = shift @_;
  my $typ    = shift @_;
  $typ = '' if !defined $typ;

  my %h;
  if ($mtitle =~ /group/i && $typ eq 'map') {
    # groups and squadrons
    for my $g (1..4) {
      my @s;
      if ($g == 1) {
	@s = (1..6);
      }
      elsif ($g == 2) {
	@s = (7..12);
      }
      elsif ($g == 3) {
	@s = (13..18);
      }
      elsif ($g == 4) {
	@s = (19..24);
      }
      my $gtitle = get_group_title($g);
      my $gf     = GEO_MAPS_USAFA::get_map_base_name('grp', $g);
      my $ghref  = "./maps/$gf";

      # the group itself as a parent
      $h{$g}{title} = $gtitle;
      #$h{$g}{class} = 'menu-temp';

      # menu items
      my $n = 1;
      # the group as a menu item
      $h{$g}{submenu}{$n}{title}  = $gtitle;
      $h{$g}{submenu}{$n}{href}   = $ghref;
      #$h{$g}{submenu}{$n}{class} = 'menu-temp';

      # and the squadrons as menu items
      for my $s (@s) {
	++$n;
	my $title = sprintf "CS-%02d", $s;
        my $sf = GEO_MAPS_USAFA::get_map_base_name('sqdn', $s);
	my $href  = "./maps/$sf";
	$h{$g}{submenu}{$n}{title} = $title;
	$h{$g}{submenu}{$n}{href}  = $href;
	#$h{$g}{submenu}{$n}{class} = 'menu-temp';
      }
    }
  }
  elsif ($mtitle =~ /state/i) {
    my $us = Geography::States->new('USA', 1); # want only 50 states
    my @states = $us->state(); # code name pairs
    # sort the list alphabetically
    my %state;
    foreach my $s (@states) {
      my $abbrv = $s->[0];
      my $state = $s->[1];
      $state{$abbrv} = $state;
    }
    # remove states for which we have no classmates
    remove_states(\%state);
    @states = (sort keys %state);

    if (0) {
      #print Dumper(\%state); die "debug exit";
      print Dumper(\@states);
      my $n = @states;
      print "Num states = $n\n";
      die "debug exit";
    }

    # split into chunks of 7 or less
    my @chunks;
    for my $i (1..10) {
      last if !@states;
      my @t;
      for my $j (1..7) {
	last if !@states;
	my  $s = shift @states;
	push @t, $s;
      }
      push @chunks, [@t];
    }
    if (0 && $debug) {
      print Dumper(\@chunks); die "debug exit";
    }

    # now for the menu
    my $nc = @chunks;
    for (my $i = 0; $i < $nc; ++$i) {
      my $g = $i + 1;

      # the chunk itself as a parent
      # title is "<first> - <last>
      my @st = @{$chunks[$i]};
      my $first  = $st[0];
      my $last   = $st[$#st];

      my $First  = $state{$first};
      my $Last   = $state{$last};

      my $gtitle = $first ne $last ? "$First - $Last" : $First;

      $h{$g}{title} = $gtitle;
      #$h{$g}{class} = 'menu-temp';

      # and the chunks of states as menu items
      my $n = 0;
      for my $s (@st) {
	++$n;
	my $title = $state{$s};
        my $sf = GEO_MAPS_USAFA::get_map_base_name('state', $s);
	my $href  = "./maps/$sf";
	$h{$g}{submenu}{$n}{title} = $title;
	$h{$g}{submenu}{$n}{href}  = $href;
	#$h{$g}{submenu}{$n}{class} = 'menu-temp';
      }
    }
  }
  elsif ($mtitle =~ /country/i) {
    # should get the countries from CL.pm
    my @c  = ('United Kingdom', 'Mexico');
    my @ca = ('UK', 'MX');

    # each country is a menu item
    my $nc = @c;
    for (my $i = 0; $i < $nc; ++$i) {
      my $n = $i + 1;
      my $title = $c[$i];
      my $ca = $ca[$i];
      my $sf = GEO_MAPS_USAFA::get_map_base_name('ctry', $ca);
      my $href  = "./maps/$sf";
      $h{$n}{title} = $title;
      $h{$n}{href}  = $href;
      #$h{$n}{class} = 'menu-temp';
    }
  }
  elsif ($typ =~ /sqdn-rosters/i) {
    #die "Tom, work this";

    # similar to maps
    # groups and squadrons
    for my $g (1..4) {
      my @s;
      if ($g == 1) {
	@s = (1..6);
      }
      elsif ($g == 2) {
	@s = (7..12);
      }
      elsif ($g == 3) {
	@s = (13..18);
      }
      elsif ($g == 4) {
	@s = (19..24);
      }

      my $gtitle = get_group_title($g);

=pod

      my $gf     = GEO_MAPS_USAFA::get_map_base_name('grp', $g);
      my $ghref  = "./maps/$gf";

=cut

      # the group itself as a parent
      $h{$g}{title} = $gtitle;
      $h{$g}{class} = 'menu-temp';

      # menu items
      my $n = 1;

=pod

      # the group as a menu item
      $h{$g}{submenu}{$n}{title} = $gtitle;
      $h{$g}{submenu}{$n}{href}  = $ghref;
      $h{$g}{submenu}{$n}{class} = 'menu-temp';

=cut

      # and the squadrons as menu items
      for my $s (@s) {
	++$n;
	my $title = sprintf "CS-%02d", $s;

        my $sf = sprintf "roster-cs-%02d.html", $s;
	my $href  = "./pages/$sf";

	$h{$g}{submenu}{$n}{title} = $title;
	$h{$g}{submenu}{$n}{href}  = $href;
	#$h{$g}{submenu}{$n}{class} = 'menu-temp';
      }
    }
  }

  return %h;
} # get_auto_menu

sub get_group_title {
  my $g = shift @_; # group number (1..4)
  my %g
    = (
       '1' => '1st Group',
       '2' => '2nd Group',
       '3' => '3rd Group',
       '4' => '4th Group',
       );

  return $g{$g};
} # get_group_title

########## data
BEGIN {
%menu
  = (
     #  0
     '0'
     => {
	 title => '50th Reunion',
	 href  => '50th-reunion.html',
	},

     #  1
     '1'
     => {
	 title => 'Lance Sijan',
	 href  => 'lance-sijan.html',
	},

     #  2
     '2'
     => {
	 title => 'Class Staff',
	 submenu
	 => {
	     '1'
	     => {
		 title => 'Senator',
		 href  => 'class-senator.html',
		},

	     '2'
	     => {
		 title => 'Officers',
		 href  => 'class-officers.html',
		},

	     '3'
	     => {
		 title => 'Sqdn Reps',
		 href  => 'cs-reps.html',
		},

	     '4'
	     => {
		 title => 'Reunion Committee',
		 href  => 'reunion-committee.html',
		},

	     '5'
	     => {
		 title => 'Research Assistants',
		 href  => 'researchers.html',
		},
	    },
	},

     #  3
     '3'
     => {
	 title => 'Class Maps',
	 submenu
	 => {
	     '1'
	     => {
		 title => 'All',
		 href  => './maps/classmates-map-all.html',
		},
	     '2'
	     => {
		 title => 'All (with names by permission)',
		 href  => './maps/classmates-map-all_show.html',
		},
	     '3'
	     => {
		 title => 'Group/Squadron',
		 type  => 'map',
		 href  => 'auto',
		},
	     '4'
	     => {
		 title => 'State',
		 href  => 'auto',
		},
	     '5'
	     => {
		 title => 'Country',
		 href  => 'auto',
		},
	     '6'
	     => {
		 title => 'Squadron Reps',
		 href  => './maps/classmates-map-reps.html',
		},
	    },
	},

     #  4
     '4'
     => {
	 title => 'Class Data',
	 submenu
	 => {
	     '1'
	     => {
		 title => 'Class Stats',
		 href  => "./pages/class-statistics.html",
		},

	     '2'
	     => {
		 title => 'Class Roster (All)',
		 href  => "./pages/class-roster-all.html",
		},

	     '3'
	     => {
		 title => 'Class Roster (Grads)',
		 href  => "./pages/class-roster-grads.html",
		},

	     '4'
	     => {
		 title => 'Squadron Rosters',
		 href  => 'auto',
		 type  => 'sqdn-rosters',
		},

	     '5'
	     => {
		 title => 'Sqdn Stats',
		 href  => "./pages/squadron-statistics.html",
		},

	     '6'
	     => {
		 title => 'Sqdn Report',
		 href  => "./pages/class-roll-call.html",
		},

	     '7'
	     => {
		 title => 'Lost Classmates',
		 href  => './pages/class-roster-lost-members.html',
		},

	     '8'
	     => {
		 title => 'Older News',
		 href  => 'old-news.html',
		},

	     '9'
	     => {
		 title => 'Classmates Only',
		 class => 'menu-warn',
		 href  => './login/index.html',
		},
	    },
	},

     #  5
     '5'
     => {
	 title => 'Class History',
	 submenu
	 => {
	     '1'
	     => {
		 title => 'Lawrence Paul: In Memoriam',
		 href  => 'class-history-lawrence-paul.html',
		},

	     '2'
	     => {
		 title => "BCT Summer of '61",
		 href  => 'class-history-bct.html',
		},

	     '3'
	     => {
		 title => "Doolie Christmas of '61",
		 href  => 'class-history-christmas-1961.html',
		},

	     '4'
	     => {
		 title => "ZI Field Trip, Summer of '62",
		 href  => 'class-history-zi-field-trip-1962.html',
		},

	     '5'
	     => {
		 title => 'Squadron Logos',
		 href  => './pages/cs-logo-history.html',
		},

	     '6'
	     => {
		 title => 'The Dodo',
		 href  => 'class-history-dodo.html',
		},
	    },
	},

     #  6
     '6'
     => {
	 title => 'Mailing Lists',
	 submenu
	 => {

	     '0'
	     => {
		 title => 'Active Lists',
		 href  => './mailing-lists.html',
		 class => 'menu-temp',
		},

	     '1'
	     => {
		 title => 'Mailing List Etiquette',
		 href  => './site-admin/mailing-list-etiquette.html',
		},
	    }
	},

     #  7
     '7'
     => {
	 title => 'Site Info',
	 submenu
	 => {
	     '0'
	     => {
		 title => 'Site Statistics',
		 href  => '/cgi-bin-cmn/show-site-statistics.cgi',
		},
	     '1'
	     => {
		 title => 'Special Features',
		 href  => './site-admin/SITE-FEATURES.txt',
		},
	     '2'
	     => {
		 title => 'Admin, Policy, and Procedures',
		 submenu
		 => {
		     '1'
		     => {
			 title => 'Site Security',
			 href  => './site-admin/SITE-SECURITY.txt',
			},
		     '2'
		     => {
			 title => 'Database Administration',
			 href  => './site-admin/DB-DUTIES.txt',
			},
		     '3'
		     => {
			 title => 'Database Fields',
			 href  => './site-admin/DATABASE-FIELDS.txt',
			},
		     '4'
		     => {
			 title => 'SSL Certificate Installation',
			 href  => './site-admin/import-ssl-certs.html',
			},
		     '5'
		     => {
			 title => 'Host Server Specs',
			 href  => './site-admin/HOST-SPECS.txt',
			},
		    },
		},
	     '3'
	     => {
		 title => 'TODO',
		 href  => 'todo-list.html',
		},

	     '4'
	     => {
		 title => 'Site History',
		 href  => 'site-changes.html',
		},

	     '5'
	     => {
		 title => 'AOG Data Requests',
		 submenu
		 => {
		     '1'
		     => {
			 title => '2010-12-01',
			 href  => 'aog-data-request-2010-12-01.png',
			},
		     '2'
		     => {
			 title => '2012-04-27',
			 href  => 'aog-data-request-2012-04-27.png',
			},
		    },
		},

	     '6'
	     => {
		 title => 'Technical Notes',
		 href  => 'inwork.html',
		 class => 'menu-temp',
		},
	    },
	},

     #  8
     '8'
     => {
	 title => 'Other Sites',
	 href  => 'other-usafa-sites.html',
	},

     #  9
     '9'
     => {
	 title => 'Memorabilia',
	 submenu
	 => {
	     '1'
	     => {
		 title => 'Wing',
		 href  => 'inwork.html',
		 class => 'menu-temp',
		},
	     '2'
	     => {
		 title => 'Group/Squadron',
		 href  => 'inwork.html',
		 #href  => 'auto',
		 class => 'menu-temp',
		},
	    },
	},

    );
} # BEGIN
